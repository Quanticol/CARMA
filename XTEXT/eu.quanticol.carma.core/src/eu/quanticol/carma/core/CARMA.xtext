grammar eu.quanticol.carma.core.CARMA with org.eclipse.xtext.common.Terminals

generate carma "http://www.quanticol.eu/carma/core/CARMA"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


Model: {Model}
	(elements += Element)*
;

Element: 
	FunctionDefinition 
	| RecordDefinition 
	| Processes 
	| ConstantDefinition 
	| ComponentDefinition 
	| EnumDefinition
	| MeasureDefinition
	| SystemDefinition
;

////////////////////////////////////////////////////RECORDS, ENUMS AND TYPES

EnumDefinition:
	'enum' name=ID '=' values += EnumCase (',' values += EnumCase ) ';'
;

RecordDefinition returns RecordDefinition hidden(ML_COMMENT,SL_COMMENT,WS):
	'record' name=ID '=' '[' fields += FieldDefinition (','  fields += FieldDefinition)* ']' ';'
;

FieldDefinition:
	fieldType=BasicType name=ID
;

ReferenceableType:
	EnumDefinition|RecordDefinition
;

EnumCase:
	name=ID
;

ConstantDefinition:
	'const' name=ID '=' value=Expression ';'
;

ValueType hidden(ML_COMMENT,SL_COMMENT,WS):
		{ProcessType} "process"	|
		BasicType
;

BasicType:
		IntegerType|
		RealType|
		BooleanType |
		CustomType
;

IntegerType: {IntegerType} "int" ;

RealType: {RealType} "real" ;

BooleanType: {BooleanType} "bool";

CustomType: {CustomType} reference=[ReferenceableType];

////////////////////////////////////////////////////VARIABLES AND REFERENCES

Variable:
	type=ValueType name=ID
;

UntypedVariable:
	name=ID
;

ReferenceableElement:
	IterationVariable |
	UntypedVariable|
	Variable|
	AttributeDeclaration|
	FunctionDefinition|
	EnumCase|
	ConstantDefinition|
	ProcessState|
	MeasureVariableDeclaration
;

////////////////////////////////////////////////////FUNCTIONS
FunctionDefinition:
	"fun" type=BasicType name=ID
	'('
	(parameters += Variable (',' parameters+=Variable)*)?
	')' body=BlockCommand
;
	
FunctionCommand:
	IfThenElseCommand 
	| ReturnCommand 
	| VariableDeclarationCommand 
	| ForCommand 
	| BlockCommand 
	| AssignmentCommand
;

AssignmentCommand:
	target=AssignmentTarget ':=' value=Expression ';'
;

AssignmentTarget:
	TargetAssignmentVariable ({TargetAssignmentField.target=current} '.' field = [FieldDefinition])*
;

TargetAssignmentVariable returns AssignmentTarget: {TargetAssignmentVariable}
	variable=[Variable]	
;

BlockCommand: {BlockCommand}
	'{'
		(commands += FunctionCommand)*
	'}'	
;

ForCommand:
	"for" "(" variable=IterationVariable ('=' start=Expression)? ";" end=Expression ";" step=Expression ")" 
		body=FunctionCommand
;

IterationVariable:
	name=ID
;

VariableDeclarationCommand:
	variable = Variable (':=' value = Expression)? ';'
;

ReturnCommand:
	'return' expression=Expression ';'
;

IfThenElseCommand:
	'if' '(' condition=Expression ')'
		thenBlock = FunctionCommand
	(=> 'else' elseBlock = FunctionCommand)?
;


////////////////////////////////////////////////////ASSIGNMENT

UpdateAssignment hidden(ML_COMMENT,SL_COMMENT,WS):
	reference=[AttributeDeclaration] ":=" expression=Expression
;

////////////////////////////////////////////////////STATE

ProcessComposition returns ProcessComposition hidden(ML_COMMENT,SL_COMMENT,WS):
	ParallelComposition
; 
	
ParallelComposition returns ProcessComposition hidden(ML_COMMENT,SL_COMMENT,WS):
	ProcessReference ({ParallelComposition.left=current}  "|" right=ProcessReference)*
;

ProcessReference returns ProcessComposition hidden(ML_COMMENT,SL_COMMENT,WS):
	 {ProcessReference} expression=[ReferenceableElement]
;

////////////////////////////////////////////////////SET COMPREHENSION

SetComp hidden(ML_COMMENT,SL_COMMENT,WS):
	{SetComp} 
	"#" 
	"{" 
	variable=ComponentComprehension
	"|"
	predicate=Expression
	"}"
; 

////////////////////////////////////////////////////COMPONENT COMPREHENSION
ComponentComprehension returns ComponentComprehension  hidden(ML_COMMENT,SL_COMMENT,WS):
	 {AllComponents} 		"*" ("[" states = ProcessComposition "]")?											|
	 {AComponentAllStates}	comp=[ComponentDefinition] "[" "*" "]"		|
	 {AComponentAState}		comp=[ComponentDefinition] "[" state = ProcessComposition "]" 
;

////////////////////////////////////////////////////SPAWN
BlockSpawn hidden(ML_COMMENT,SL_COMMENT,WS):
	{BlockSpawn} comp+=ComponentBlockInstantiation ("," comp+=ComponentBlockInstantiation+)*
;

//////////////////////////////////////////////////////PREDEFINED METHODS	
//PreFunctionCall returns PreFunctionCall hidden(ML_COMMENT,SL_COMMENT,WS):
//	(	
//	{PDFunction} 		name="PDF"		| 
//	{UniformFunction} 	name="Uniform"	| 
//	{CeilingFunction} 	name="Ceiling"	|
//	{FloorFunction} 	name="Floor"	|
//	{MaxFunction}		name="Max"		|
//	{MinFunction}		name="Min"
//	)
//	arguments=PredFunctionCallArguments 
//;


////////////////////////////////////////////////////COMPONENT
ComponentDefinition hidden(ML_COMMENT,SL_COMMENT,WS):
	"component" name=ID '(' (parameters += Variable (',' parameters +=Variable )*)? ')'
	"{"
	store=StoreBlock
	processes=ProcessesBlock
	initBlock=InitBlock
	"}"
;

StoreBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{StoreBlock}
	"store" 
	"{" 
		(attributes+=AttributeDeclaration ";" )*
	"}"
;

AttributeDeclaration:
	{AttributeConstDeclaration} "const" name=ID ":=" value=Expression
	| {AttibuteVarDeclaration} "attrib" name=ID  ":=" value=Expression
;
	
ProcessesBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProcessesBlock}
	"behaviour"
	"{"
		(processes+=ProcessState ";" )*
	"}"
;

InitBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{InitBlock}
	"init" 
	"{" 
		init=ProcessComposition
	"}"
;

SystemDefinition:
	"system" name=ID '{'
		'collective' '{'
			collective += ComponentBlockDeclaration (collective+=ComponentBlockDeclaration)*			
		'}'
		(environment=Environment)?
		
	'}'
;

ComponentBlockDeclaration :
	(  
		ComponentBlockNew |  
		ComponentBlockForStatement |
		ComponentBlockConditionalStatement 
	)
;

ComponentBlockConditionalStatement:
	"if" '(' guard=Expression ')' '{'
		(thenBranch += ComponentBlockDeclaration)*
	'}' (=> 'else' '{'
		(elseBranch += ComponentBlockDeclaration)*
	'}'	
	)?
;
	
ComponentBlockNew returns ComponentBlockInstantiation:
	ComponentBlockInstantiation
	";"
;

ComponentBlockInstantiation hidden(ML_COMMENT,SL_COMMENT,WS):
	"new"
	name=[ComponentDefinition] 
	'(' (arguments+=Range (',' arguments+=Range)* )? ')'
//	("["population=INT"]")?
;

ComponentBlockForStatement hidden(ML_COMMENT,SL_COMMENT,WS):
	"for" "(" variable=IterationVariable ";" expression=Expression ";" afterThought=Expression ")" '{'
			(collective += ComponentBlockDeclaration)*			
	'}'
;

////////////////////////////////////////////////////PROCESS
Processes hidden(ML_COMMENT,SL_COMMENT,WS): {Processes}
	"abstract" "{"
		( processes+=ProcessState ";" )*
	"}"
;

ProcessState hidden(ML_COMMENT,SL_COMMENT,WS):
	name=ID
	"="
	processExpression=ProcessExpression 
;

ProcessExpression returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	ProcessExpressionChoice
;

ProcessExpressionChoice returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	ProcessExpressionGuard ({ProcessExpressionChoice.left=current}  "+" right=ProcessExpressionGuard)*
;

ProcessExpressionGuard returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProcessExpressionGuard} guard=Guard expression=ProcessExpressionGuard
	| ProcessExpressionPrimary
;

ProcessExpressionPrimary returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	"(" ProcessExpression ")" |
	ProcessExpressionAction
;

ProcessExpressionAction hidden(ML_COMMENT,SL_COMMENT,WS):
	action=Action "." next=ProcessExpressionNext	
;

ProcessExpressionNext:
		{ProcessExpressionNil} "nil"
	| {ProcessExpressionKill} "kill"
	| {ProcessExpressionReference} expression=[ProcessState]
;

Guard hidden(ML_COMMENT,SL_COMMENT,WS):
	"[" booleanExpression=Expression "]"
;

Activity:
	name=ID (isBroadacst?='*')? (predicate=ActionGuard)? 	
;

Action hidden(ML_COMMENT,SL_COMMENT,WS):
	Activity (
		{OutputAction.activity=current} 
			(withData?="<" (outputArguments+=Expression ( "," outputArguments+=Expression )*)? ">")? 
			(update=Update)?
		| {InputAction.activity=current} 
			"(" 
				(parameters+=UntypedVariable
				( "," parameters+=UntypedVariable )* )?
			")"
			(update=Update)?
	)
;

//IO hidden(ML_COMMENT,SL_COMMENT,WS):
//	( 
//		InputAction			|
//		OutputAction
//	)
//;
//
//InputAction returns IO  hidden(ML_COMMENT,SL_COMMENT,WS):
//	{InputAction}  "(" 
//	(parameters+=UntypedVariable
//	( "," parameters+=UntypedVariable )* )?
//	")"
//;
//
//OutputAction returns IO hidden(ML_COMMENT,SL_COMMENT,WS):
//	{OutputAction} "<"
//	(outputArguments+=Expression
//	( "," outputArguments+=Expression )*)?
//	">"
//;



Update hidden(ML_COMMENT,SL_COMMENT,WS):
	{Update} "{" (updateAssignment+=UpdateAssignment ( "," updateAssignment+=UpdateAssignment)*)? "}"
;

ActionGuard hidden(ML_COMMENT,SL_COMMENT,WS):
	{ActionGuard} "[" guard=Expression "]"
;
////////////////////////////////////////////////////Expression

Range returns Expression:
	Expression ({Range.min=current} ":" max=Expression (":" step=Expression)?)?
;



Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	Or
;

Or returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	And ({Or.left=current} "||" 
		right=And
	)*
;

And returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	Relation ({And.left=current} "&&" 
		right=Relation
	)*
;
	
Relation returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	SumDiff (
		{Equality.left=current} '==' right=SumDiff
		| {DisEquality.left=current} '!=' right=SumDiff
		| {Less.left=current} '<' right=SumDiff
		| {LessOrEqual.left=current} '<=' right=SumDiff
		| {Greater.left=current} '>' right=SumDiff
		| {GreaterOrEqual.left=current} '>=' right=SumDiff
	)?
;

SumDiff returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	MulDiv (
		{Subtraction.left=current} '-' right=MulDiv
		| {Addition.left=current} '+' right=MulDiv
	)*
;

MulDiv returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	Modulo ({Multiplication.left=current} '*' right=Modulo
		| {Division.left=current} '/' right=Modulo
	)*
;

Modulo returns Expression hidden(ML_COMMENT,SL_COMMENT,WS): 
	Primary ({Modulo.left=current} '%' 
		right=Primary
	)?
;

Primary returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	'(' Expression 	({IfThenElseExpression.guard=current} "?" thenBranch=Expression ":" elseBranch=Expression)? ")" | 
	{Not} "!" expression=Primary |
	{UnaryPlus} '+' expression=Primary |
	{UnaryMinus} '-' expression=Primary | 
	RecordAccess 	
;

RecordAccess returns Expression:
	Atomic ( {RecordAccess.source=current} '.' field=[FieldDefinition] )*
;

Atomic returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	Reference 
	| {AtomicTrue} "true"
	| {AtomicFalse} "false"
	| {AtomicInteger} value=INT 
	| {AtomicReal} value=REAL 
	| {AtomicRecord} '[' fields += FieldAssignment (',' fields += FieldAssignment)* ']' 
	| {AtomicNow} "now" 
	| SetComp				
	| {AtomicRnd} "RND"
	| {AtomicPi} "PI"
	| {AtomicExp} "E"
	| BuiltInFunctions
	| {MyContext} "my" "." reference=[AttributeDeclaration]
	| {ReceiverContext} "receiver" "." reference=[AttributeDeclaration]
	| {SenderContext} "sender" "." reference=[AttributeDeclaration]
	| {GlobalContext} "global" "." reference=[AttributeDeclaration]
	| {CastToReal} "real" '(' arg=Expression ')'
	| {CastToInteger} "int" '(' arg=Expression ')'
//	| {AtomicOutcome}				value=OutcomeProbability	THE ROLE OF THIS CASES IS NOT CLEAR FOR ME.
//	| {AtomicProcessComposition}	value=ProcessComposition
;

BuiltInFunctions returns Expression :
	{AbsFunction} "abs" '(' arg=Expression ')' 
			//The absolute value of arg.
	| {AcosFunction} "acos" '(' arg=Expression ')' 
			//The arc cosine of arg; the returned angle is in the range 0.0 through pi.
	| {AsinFunction} "asin" '(' arg=Expression ')' 
			//The arc sine of a value; the returned angle is in the range -pi/2 through pi/2.
	| {AtanFunction} "atan" '(' arg=Expression ')' 
			//Returns the arc tangent arg; the returned angle is in the range -pi/2 through pi/2.
	| {Atan2Function} "atan2" '(' first=Expression ',' second=Expression ')'
			//The angle theta from the conversion of rectangular coordinates (first, second) to polar coordinates (r, theta).
	| {CbrtFunction} "cbrt" '(' arg=Expression ')'
			//The cube root of arg.
	| {CeilFunction} "ceil" '(' arg=Expression ')'
			//The smallest (closest to negative infinity) double value that is greater than or equal to the argument and is equal to a mathematical integer.
	| {CosFunction} "cos" '(' arg=Expression ')'
			//Returns the trigonometric cosine of an angle.
	| {ExpFunction} "exp" '(' arg=Expression ')'
			//Returns Euler's number e raised to the power of a double value.
	| {FloorFunction} "floor" '(' arg=Expression ')'
			//Returns the largest (closest to positive infinity) double value that is less than or equal to the argument and is equal to a mathematical integer.
	| {LogFunction} "log" '(' arg=Expression ')'
			//Returns the natural logarithm (base e) of a double value.
	| {Log10Function} "log10" '(' arg=Expression ')'
			//Returns the base 10 logarithm of a double value.
	| "max" ({MaxFunction} '(' first=Expression ',' second=Expression ')'
		| {MaxMeasure} '{' value=Expression ('|' guard=Expression)? '}'
	)
	| "min" ({MinFunction} '(' first=Expression ',' second=Expression ')'
		| {MinMeasure} '{' value=Expression ('|' guard=Expression)? '}'
	)
	| "avg" {AverageMeasure} '{' value=Expression ('|' guard=Expression)? '}'
	| {PowFunction} "pow" '(' first=Expression ',' second=Expression ')'
	| {SinFunction} "sin" '(' arg=Expression ')'
			//Returns the trigonometric sine of an angle.
	| {SqrtFunction} "sqrt" '(' arg=Expression ')'
			//Returns the correctly rounded positive square root of a double value.
	| {TanFunction} "tan" '(' arg=Expression ')'
			//Returns the trigonometric tangent of an angle.
	| {UniformFunction} "U" '(' args+=Expression (',' args+=Expression)* ')' 
;

FieldAssignment:
	field=[FieldDefinition] ':=' value=Expression
;

////////////////////////////////////////////////////REFERENCE


Reference hidden(ML_COMMENT,SL_COMMENT,WS):
	reference=[ReferenceableElement] ( isCall ?= '(' ( args+=Expression ( ',' args+=Expression )* )? ')' )?
;

////////////////////////////////////////////////////MEASURES

MeasureDefinition hidden(ML_COMMENT,SL_COMMENT,WS):
	"measure" name=ID 
		("[" variables+=MeasureVariableDeclaration("," variables+=MeasureVariableDeclaration+)* "]" )?
		"="  measure=Expression  ';'
;

MeasureVariableDeclaration hidden(ML_COMMENT,SL_COMMENT,WS):
	{MeasureVariableDeclaration} name=ID	":="	assign= Range
;

	
////////////////////////////////////////////////////ENVIRONMENT	
Environment hidden(ML_COMMENT,SL_COMMENT,WS):
	{Environment}
	"environment" 
	"{"
	(store=StoreBlock)?
	(probabilityBlock=ProbabilityBlock)?
	(rateBlock=RateBlock)?
	(updateBlock=UpdateBlock)?
	"}"
;

ProbabilityBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProbabilityBlock}
	"prob" 
	"{"
		(probabilities+=Probability ";")*
		("default" ":" value=Expression ";")?
	"}"
;
	
Probability hidden(ML_COMMENT,SL_COMMENT,WS):
	(guard=Guard)? stub=ActionStub ":" expression=Expression
;

RateBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{RateBlock}
	"rate"
	"{"
		(rates+=Rate+ ";")*
		("default" ":" value=Expression ";")?
	"}"
;

Rate hidden(ML_COMMENT,SL_COMMENT,WS):
	{Rate}
	(guard=Guard)? stub=ActionStub ":" expression=Expression
;
	
UpdateBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{UpdateBlock}
	"update"
	"{"
		(updates+=EnvironmentUpdate+ ";")*
	"}"
;

EnvironmentUpdate hidden(ML_COMMENT,SL_COMMENT,WS):
	(guard=Guard)? stub=ActionStub ":" 
	( 
		(update+=UpdateAssignment ("," expression+=UpdateAssignment+)* (',' spawn=BlockSpawn)?)
		| spawn=BlockSpawn
	)
;

ActionStub hidden(ML_COMMENT,SL_COMMENT,WS):
	{ActionStub} activity=[Activity] (isBroadcast?='*')?
;


terminal REAL returns ecore::EDouble: (('0'..'9')+ '.' ('0' .. '9')+)|('.'('0' .. '9')*);
