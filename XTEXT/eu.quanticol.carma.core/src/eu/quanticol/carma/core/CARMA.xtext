grammar eu.quanticol.carma.core.CARMA with org.eclipse.xtext.common.Terminals

generate carma "http://www.quanticol.eu/carma/core/CARMA"


Model:
	(methods=Methods)?
	(records=Records)?
	components=ComponentStyle
;

////////////////////////////////////////////////////PRIMITIVES

PrimitiveType returns PrimitiveType hidden(ML_COMMENT,SL_COMMENT,WS):
	CarmaDouble |
	CarmaInteger|
	CarmaBoolean|
	Range	
;

CarmaDouble returns PrimitiveType hidden(ML_COMMENT,SL_COMMENT,WS):
	{CarmaDouble} (negative="-")? left=INT "." right=INT (exponent=CarmaExponent)?
;

CarmaExponent returns CarmaExponent hidden(ML_COMMENT,SL_COMMENT,WS):
	'^' (negative="-")? exponent=INT
;


CarmaInteger returns PrimitiveType hidden(ML_COMMENT,SL_COMMENT,WS):
	{CarmaInteger} (negative="-")? value=INT
;

CarmaBoolean returns PrimitiveType hidden(ML_COMMENT,SL_COMMENT,WS):
	{CarmaBoolean} value=BOOLEANVALUE
;

Range returns PrimitiveType hidden(ML_COMMENT,SL_COMMENT,WS):
	{Range} min=INT ".." max=INT
;

OutcomeProbability returns PrimitiveType hidden(ML_COMMENT,SL_COMMENT,WS):
	{OutcomeProbability} outcome=(CarmaInteger|VariableReference) ":" probability=CarmaDouble
;

////////////////////////////////////////////////////RECORDS

Records returns Records hidden(ML_COMMENT,SL_COMMENT,WS): 
	"records""{"
	recordDefinitions+=RecordDefinition
	("," recordDefinitions+=RecordDefinition)*
	"}"
;

RecordDefinition returns RecordDefinition hidden(ML_COMMENT,SL_COMMENT,WS): 
	recordSignature=RecordSignature
	recordDefinitionStatementBlock=RecordDefinitionStatementBlock
;

RecordSignature  returns RecordSignature hidden(ML_COMMENT,SL_COMMENT,WS):
	"record" class=RecordClassName 
	recordDefinitionArguments=RecordParameters
; 

RecordParameters hidden(ML_COMMENT,SL_COMMENT,WS): 
	{RecordParameters} "("
	(parameters+=AttribParameter
	( "," parameters+=AttribParameter )*)?
	")"
;

RecordDefinitionStatementBlock hidden(ML_COMMENT,SL_COMMENT,WS): 
	"{"
		  attributes+=RecordAttribVariableDeclaration ";"
		  (attributes+=RecordAttribVariableDeclaration ";")*
	"}"
;

RecordArguments hidden(ML_COMMENT,SL_COMMENT,WS): 
	{RecordArguments} "("
	(arguments+=RecordArgument
	( "," arguments+=RecordArgument )*)?
	")"
;

RecordArgument hidden(ML_COMMENT,SL_COMMENT,WS): 
	{RecordArgument} argument=(VariableReference | CarmaInteger)
;

RecordAsArgument hidden(ML_COMMENT,SL_COMMENT,WS): 
	"new" instantiate=[RecordClassName|UPPERST] arguments=RecordArguments 
;

////////////////////////////////////////////////////VARIABLES

VariableName returns Name hidden(ML_COMMENT,SL_COMMENT,WS):
	{VariableName} name=LOWERST
;

RecordName returns Name hidden(ML_COMMENT,SL_COMMENT,WS):
	{RecordName} name=LOWERST
;

ActionName returns Name  hidden(ML_COMMENT,SL_COMMENT,WS):
	{ActionName} name=LOWERST
;

ProcessName returns Name  hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProcessName} name=UPPERST
;

ComponentName returns Name  hidden(ML_COMMENT,SL_COMMENT,WS):
	{ComponentName} name=UPPERST
;

MacroName returns Name  hidden(ML_COMMENT,SL_COMMENT,WS):
	{MacroName} name=[ProcessName|UPPERST]
;

MethodName returns Name  hidden(ML_COMMENT,SL_COMMENT,WS):
	{MethodName} name=UPPERST
;

MeasureName returns Name  hidden(ML_COMMENT,SL_COMMENT,WS):
	{MeasureName} name=UPPERST
;

SystemName returns Name hidden(ML_COMMENT,SL_COMMENT,WS):
	{SystemName} name=UPPERST
;

RecordClassName returns Name hidden(ML_COMMENT,SL_COMMENT,WS):
	{RecordClassName} name=UPPERST
;

AttribParameter returns AttribParameter hidden(ML_COMMENT,SL_COMMENT,WS):
	type=AttribLabel	name=VariableName
;

RecordParameter returns RecordParameter hidden(ML_COMMENT,SL_COMMENT,WS):
	type=[RecordClassName|UPPERST] name=VariableName
;

DoubleParameter returns DoubleParameter hidden(ML_COMMENT,SL_COMMENT,WS):
	type=DoubleLabel	name=VariableName
;

IntgerParameter returns IntgerParameter hidden(ML_COMMENT,SL_COMMENT,WS):
	type=IntgerLabel	name=VariableName
;

MacroParameter returns MacroParameter hidden(ML_COMMENT,SL_COMMENT,WS):
	assignee=ProcessName
; 


Types returns Types hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		{DoubleTypeLabel} 		type=DoubleLabel 	|
		{IntegerTypeLabel} 		type=IntgerLabel	|
		{AttribTypeLabel}		type=AttribLabel	|
		{RecordTypeLabel}		ref=[RecordClassName|UPPERST]
	)
;

DoubleLabel hidden(ML_COMMENT,SL_COMMENT,WS):
	"double"
;

IntgerLabel hidden(ML_COMMENT,SL_COMMENT,WS):
	"int"
;

AttribLabel hidden(ML_COMMENT,SL_COMMENT,WS):
	"attrib"
;

Parameters returns Parameters hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		AttribParameter |
		RecordParameter |
		DoubleParameter	|
		IntgerParameter
	)
;

PreArguments returns PreArguments hidden(ML_COMMENT,SL_COMMENT,WS):
		value=Expression	
;


CompParameters returns CompParameters hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		AttribParameter |
		RecordParameter |
		MacroParameter
	)
;

CompArguments returns CompArguments hidden(ML_COMMENT,SL_COMMENT,WS):
		value=Expression	
;

Arguments returns Arguments hidden(ML_COMMENT,SL_COMMENT,WS):
		value=Expression	
;

VariableReference returns VariableReference hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		{VariableReferencePure} 					name=[VariableName|LOWERST] |
		{VariableReferenceMy} 		"my" 		"." name=[VariableName|LOWERST] |
		{VariableReferenceThis} 	"this" 		"." name=[VariableName|LOWERST] |
		{VariableReferenceReceiver}	"receiver" 	"." name=[VariableName|LOWERST] |
		{VariableReferenceSender}	"sender" 	"."	name=[VariableName|LOWERST] |
		{VariableReferenceGlobal}	"global"	"." name=[VariableName|LOWERST] |
		{RecordReferencePure} 						name=[VariableName|LOWERST]
		"." record=[RecordName|LOWERST]	|
		{RecordReferenceMy} 		"my" 		"." name=[VariableName|LOWERST]
		"." record=[RecordName|LOWERST]	|
		{RecordReferenceThis} 		"this" 		"." name=[VariableName|LOWERST]
		"." record=[RecordName|LOWERST]	|
		{RecordReferenceReceiver}	"receiver" 	"." name=[VariableName|LOWERST]
		"." record=[RecordName|LOWERST]	|
		{RecordReferenceSender}		"sender" 	"."	name=[VariableName|LOWERST]
		"." record=[RecordName|LOWERST] |
		{RecordReferenceGlobal}		"global" 	"."	name=[VariableName|LOWERST]
		"." record=[RecordName|LOWERST]
	)
;


AttribVariableDeclaration returns AttribVariableDeclaration hidden(ML_COMMENT,SL_COMMENT,WS):
	type=AttribLabel	name=VariableName	":="	assign=Expression 
;

RecordAttribVariableDeclaration returns RecordAttribVariableDeclaration hidden(ML_COMMENT,SL_COMMENT,WS):
	type=AttribLabel	name=RecordName	":="	assign=Expression
;

MeasureVariableDeclaration returns MeasureVariableDeclaration hidden(ML_COMMENT,SL_COMMENT,WS):
	type=AttribLabel	name=VariableName	":="	assign=Expression
;

IntgerVariableDeclaration returns IntgerVariableDeclaration hidden(ML_COMMENT,SL_COMMENT,WS):
	type=IntgerLabel	name=VariableName	":="	assign=Expression
;

DoubleVariableDeclaration returns DoubleVariableDeclaration hidden(ML_COMMENT,SL_COMMENT,WS):
	type=DoubleLabel	name=VariableName	":="	assign=Expression
;

RecordDeclaration returns RecordDeclaration hidden(ML_COMMENT,SL_COMMENT,WS):
	type=[RecordClassName|UPPERST] name=VariableName ":=" ( 
		"new" instantiate=[RecordClassName|UPPERST] arguments=RecordArguments |
		assign=VariableReference
		)
;

MethodDeclaration returns MethodDeclaration hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		AttribVariableDeclaration |
		IntgerVariableDeclaration |
		DoubleVariableDeclaration |
		RecordDeclaration
	)
;

StoreDeclaration returns StoreDeclaration hidden(ML_COMMENT,SL_COMMENT,WS):
	(AttribVariableDeclaration | RecordDeclaration)
;

MeasureAssignment returns MeasureAssignment hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		{MeasureAssignmentCarmaInteger} 	naturalValue = CarmaInteger		|
		{MeasureAssignmentRange} 			range=Range
	)
;

AttribAssignment returns AttribAssignment hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		{AttribAssignmentCarmaInteger} 		naturalValue = CarmaInteger		|
		{AttribAssignmentVariableName} 		ref=VariableReference
	)
;

DoubleAssignment returns DoubleAssignment hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		{DoubleAssignmentCarmaDouble} 		doubleValue = 	CarmaDouble		|
		{DoubleAssignmentMethodReference} 	method 		= 	MethodReference |
		{DoubleAssignmentVariableName} 		reference 	= 	VariableReference
	)
;

IntgerAssignment returns IntgerAssignment hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		{IntgerAssignmentCarmaInteger} 		integerValue 	= CarmaInteger		|
		{IntgerAssignmentMethodReference} 	method 			= MethodReference 	|
		{IntgerAssignmentVariableName} 		reference 		= VariableReference
	)	
;

MethodReference returns MethodExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		{MethodReferenceMan}	ref=MethodCall |
		{MethodReferencePre}	ref=PreMethodCall
	)
;

////////////////////////////////////////////////////MACRO

Macro returns MacroExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	MacroExpressionParallel
; 
	
MacroExpressionParallel returns MacroExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	MacroExpressionReference ({MacroExpressionParallel.left=current}  "|" right=MacroExpressionReference)*
;

MacroExpressionReference returns MacroExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	 {MacroExpressionReference} name=MacroName
;

////////////////////////////////////////////////////SET COMPREHENSION

SetComp returns EnvironmentExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{SetComp} 
	"#" 
	"{" 
	componentReference=EnvironmentMacro
	"|"
	booleanExpression=BooleanExpression
	"}"
; 

////////////////////////////////////////////////////ENVIRONMENTMACRO

EnvironmentMacro returns EnvironmentMacroExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	EnvironmentMacroExpressionParallel
; 

EnvironmentMacroExpressionParallel returns EnvironmentMacroExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	EnvironmentMacroAtomic ({EnvironmentMacroExpressionParallel.left=current}  "&" right=EnvironmentMacroAtomic)*
;

EnvironmentMacroAtomic returns EnvironmentMacroExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	 {EnvironmentMacroExpressionAll} 					"*" 											|
	 {EnvironmentMacroExpressionComponentAllStates}		comp=[ComponentName|UPPERST] "[" "*" "]"		|
	 {EnvironmentMacroExpressionComponentAState}		comp=[ComponentName|UPPERST] "[" state=Macro "]"
;

////////////////////////////////////////////////////SPAWN

Spawn hidden(ML_COMMENT,SL_COMMENT,WS):
	{Spawn} Spawn=(BlockSpawn | LineSpawn)
;

BlockSpawn hidden(ML_COMMENT,SL_COMMENT,WS):
	{BlockSpawn} comp+=ComponentBlockSpawn ("," comp+=ComponentBlockSpawn+)*
;

LineSpawn hidden(ML_COMMENT,SL_COMMENT,WS):
	{LineSpawn} comp+=ComponentLineDefinitionSpawn ("," comp+=ComponentLineDefinitionSpawn+)*
;

////////////////////////////////////////////////////FUNCTIONS


Methods hidden(ML_COMMENT,SL_COMMENT,WS):
	methods+=MethodDefinition+
;

MethodDefinition hidden(ML_COMMENT,SL_COMMENT,WS):
	{MethodDefinition}
	"fun"
	type=Types
	name=MethodName
	functionArguments=MethodDefinitionParameters
	functionExpression=MethodBody
;
	
MethodDefinitionParameters hidden(ML_COMMENT,SL_COMMENT,WS):
	{MethodDefinitionParameters}
	"("
	(inputArguments+=MethodDefinitionParameter
	( "," inputArguments+=MethodDefinitionParameter )*)?
	")"
;

MethodDefinitionParameter hidden(ML_COMMENT,SL_COMMENT,WS):
	parameters=Parameters
;
	
MethodBody hidden(ML_COMMENT,SL_COMMENT,WS):
	{MethodBody} 
	"{" 
	statements+=MethodStatement* 
	"}"
;
	
MethodStatement hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		MethodDeclaration 			|
		MethodAssignment		 	|
		MethodReturn				|
		MethodIfStatement 			|
		MethodForStatement
	)
	";"
;


MethodIfStatement hidden(ML_COMMENT,SL_COMMENT,WS):
	"if" "(" expression=BooleanExpression ")"
	thenBlock=MethodIfBlock
	(=>"else" elseBlock=MethodIfBlock)?
;
	

MethodIfBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	statements += MethodStatement |
 '{' statements += MethodStatement+ '}'
;
	

MethodForStatement hidden(ML_COMMENT,SL_COMMENT,WS):
	"for" "(" variable=AttribVariableDeclaration ";" expression=BooleanExpression ";" afterThought=MethodAfterThought")" 
	MethodForBlock=MethodForBlock
;
	

MethodAfterThought hidden(ML_COMMENT,SL_COMMENT,WS):
	{MethodAfterThought}
	name=VariableReference ":=" expression=MethodExpression
;
	
MethodForBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	statements += MethodStatement |
 	'{' 
 	statements += MethodStatement+ 
 	'}'
;	

MethodCall hidden(ML_COMMENT,SL_COMMENT,WS):
	{MethodCall} name=[MethodName|UPPERST]
	arguments=MethodCallArguments 
;
	
MethodCallArguments hidden(ML_COMMENT,SL_COMMENT,WS):
	{MethodCallArguments}
	"("
	(arguments+=Arguments
	( "," arguments+=Arguments )*)?
	")"
;

MethodAssignment hidden(ML_COMMENT,SL_COMMENT,WS):
 	assignee=VariableReference ":=" expression=MethodExpression
;
	 

MethodReturn hidden(ML_COMMENT,SL_COMMENT,WS):
	"return" expression=MethodExpression
;
	
MethodExpression returns MethodExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{MethodExpression} expression=MethodSubtraction
;
	
MethodSubtraction returns MethodExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	MethodAddition ({MethodSubtraction.left=current} '-' 
		right=MethodAddition
	)*
;

MethodAddition returns MethodExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	MethodMultiplication ({MethodAddition.left=current} '+' 
		right=MethodMultiplication
	)*
;

MethodMultiplication returns MethodExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	MethodModulo ({MethodMultiplication.left=current} '*' 
		right=MethodModulo
	)*
;

MethodModulo returns MethodExpressions hidden(ML_COMMENT,SL_COMMENT,WS): 
	MethodDivision ({MethodModulo.left=current} '%' 
		right=MethodDivision
	)*
;

MethodDivision returns MethodExpressions hidden(ML_COMMENT,SL_COMMENT,WS): 
	MethodPrimary ({MethodDivision.left=current} '/' 
		right=MethodPrimary
	)*
;

MethodPrimary returns MethodExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	'(' MethodExpression ')' | 
	MethodAtomic
;

MethodAtomic returns MethodExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{MethodAtomicPrimitive}			value=PrimitiveType 	|
	{MethodAtomicVariable}			value=VariableName 		|
	{MethodAtomicMethodReference}	value=MethodReference	|
	{MethodRecordDeclaration}		value=RecordDeclaration
;

////////////////////////////////////////////////////PREDEFINED METHODS	
	
PreMethodCall returns PreMethodCall hidden(ML_COMMENT,SL_COMMENT,WS):
	(	
	{PDFunction} 		name="PDF"		| 
	{UniformFunction} 	name="Uniform"	| 
	{CeilingFunction} 	name="Ceiling"	|
	{FloorFunction} 	name="Floor"	|
	{MaxFunction}		name="Max"		|
	{MinFunction}		name="Min"
	)
	 
	functionArguments=PredMethodCallArguments 
	
;
	
PredMethodCallArguments hidden(ML_COMMENT,SL_COMMENT,WS):
	{PredMethodCallArguments} 
	"("
	(arguments+=PreArguments
	( "," arguments+=PreArguments )*)?
	")"
;

////////////////////////////////////////////////////COMPONENT

ComponentStyle returns ComponentStyle hidden(ML_COMMENT,SL_COMMENT,WS):
	(  
	{BlockStyle}
	definitions+=ComponentBlockDefinition+
	(processes=Processes)?
	(measures=MeasureBlock)?
	system=BlockSystem
	|
	{LineStyle}
	(measures=MeasureBlock)?
	system=LineSystem
	)
;
	
ComponentBlockDefinition returns Component hidden(ML_COMMENT,SL_COMMENT,WS):
	{ComponentBlockDefinition}
	componentSignature=ComponentBlockSignature
	componentBlock=ComponentBlock
	
;

ComponentBlockSignature returns ComponentSignature hidden(ML_COMMENT,SL_COMMENT,WS):
	"component"
	name=ComponentName
	componentParameters=ComponentParameters
;
	
ComponentParameters hidden(ML_COMMENT,SL_COMMENT,WS):
	{ComponentParameters}
	"("
	(parameters+=CompParameters
	( "," parameters+=CompParameters )*)?
	")"
;
	
ComponentBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	"{"
	store=StoreBlock
	processes+=ProcessesBlock
	initBlock=InitBlock
	"}"
;
	
StoreBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{StoreBlock}
	"store" 
	"{" 
	(attributes+=StoreDeclaration ";"
	( attributes+=StoreDeclaration ";" )*)?
	"}"
;
	
ProcessesBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProcessesBlock}
	"behaviour"
	"{"
	(processes+=Process ";"
	( processes+=Process ";" )*)?
	"}"
;

InitBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{InitBlock}
	"init" 
	"{" 
	init=Macro
	";"
	"}"
;

BlockSystem returns System:
	{BlockSystem}
	"system" name=SystemName "{"
	collective=BlockCollective
	(environment=Environment)?
	"}"
;

BlockCollective hidden(ML_COMMENT,SL_COMMENT,WS):
	"collective" "{"
	declarations+=ComponentBlockDeclaration+
	"}"
;
	
ComponentBlockDeclaration hidden(ML_COMMENT,SL_COMMENT,WS):
	(  ComponentBlockNew |  ComponentBlockForStatement )
;
	
ComponentBlockNew returns CBND hidden(ML_COMMENT,SL_COMMENT,WS):
	{ComponentBlockNew}
	"new"
	name=[ComponentName|UPPERST] 
	arguments=ComponentBlockArguments
	("["population=INT"]")?
	";"
;

ComponentBlockSpawn returns CBND hidden(ML_COMMENT,SL_COMMENT,WS):
	{ComponentBlockSpawn}
	"new"
	name=[ComponentName|UPPERST] 
	arguments=ComponentBlockArguments
	("["population=INT"]")?
;

ComponentBlockArguments hidden(ML_COMMENT,SL_COMMENT,WS):
	{ComponentBlockArguments}
	"("
	(arguments+=CompArguments
	( "," arguments+=CompArguments )*)?
	")"
;

ComponentBlockForStatement hidden(ML_COMMENT,SL_COMMENT,WS):
	"for" "(" variable=AttribVariableDeclaration ";" expression=BooleanExpression ";" afterThought=ComponentAfterThought")" 
	componentBlockForBlock=ComponentBlockForBlock
;

ComponentBlockForBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	"{"
	component=ComponentBlockNew
	"}" ";"
;

LineSystem returns System:
	{LineSystem}
	"system" name=SystemName "{"
	collective=LineCollective
	processes=Processes
	(environment=Environment)?
	"}"
;

LineCollective hidden(ML_COMMENT,SL_COMMENT,WS):
	"collective" "{"
	components+=ComponentLine+
	"}"
;


ComponentLine returns Component hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		{ComponentLineForStatement} component=ComponentLineForStatement |
		{ComponentLineDefinition} component=ComponentLineDefinition
	)
;
	
ComponentLineForStatement hidden(ML_COMMENT,SL_COMMENT,WS):
	"for" "(" variable=AttribVariableDeclaration ";" expression=BooleanExpression ";" afterThought=ComponentAfterThought")" 
	componentBlockForBlock=ComponentLineForBlock
;

ComponentLineForBlock hidden(ML_COMMENT,SL_COMMENT,WS):
		"{"
		component=ComponentLineDefinition
		"}" ";"
;
	
ComponentLineDefinition returns Component hidden(ML_COMMENT,SL_COMMENT,WS):
	{ComponentLineDefinition}
	componentSignature=ComponentLineSignature
	("["population=INT"]")?
	";"
;

ComponentLineSignature returns ComponentSignature hidden(ML_COMMENT,SL_COMMENT,WS):
	name=ComponentName
	"("
	init=Macro
	","
	"{"
	store=StoreLine
	"}"
	")"
;

ComponentLineDefinitionSpawn returns Component hidden(ML_COMMENT,SL_COMMENT,WS):
	{ComponentLineDefinitionSpawn}
	name=ComponentName
	"("
	init=Macro
	","
	"{"
	store=StoreLine
	"}"
	")"
	("["population=INT"]")?
;
	
StoreLine hidden(ML_COMMENT,SL_COMMENT,WS):
	{StoreLine}
	(attributes+=StoreDeclaration
	( "," attributes+=StoreDeclaration )*)?
;
	
ComponentAfterThought hidden(ML_COMMENT,SL_COMMENT,WS):
	{ComponentAfterThought}
	name=VariableReference ":=" expression=MethodExpression
;
	
////////////////////////////////////////////////////PROCESS

Processes hidden(ML_COMMENT,SL_COMMENT,WS):
	"abstract" "{"
	processes+=Process ";"
	( processes+=Process ";" )*
	"}"
;

Process hidden(ML_COMMENT,SL_COMMENT,WS):
	name=ProcessName
	"="
	processExpression=ProcessExpression 
;

ProcessExpression returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	ProcessExpressionChoice
;

ProcessExpressionChoice returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	ProcessExpressionPrimary ({ProcessExpressionChoice.left=current}  "+" right=ProcessExpressionPrimary)*
;

ProcessExpressionPrimary returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	"(" ProcessExpression ")" |
	ProcessExpressionAtomic
;

ProcessExpressionAtomic returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	ProcessExpressionLeaf					|
	ProcessExpressionGuard 					|
	ProcessExpressionAction 				|
	ProcessExpressionReference 
;

ProcessExpressionGuard returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProcessExpressionGuard} expression=Guard
	reference=ProcessExpressionPrimary
;

ProcessExpressionAction returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProcessExpressionAction} expression=Action
	"."
	reference=ProcessExpressionPrimary
;

ProcessExpressionReference returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProcessExpressionReference} expression=[ProcessName|UPPERST]
;

ProcessExpressionLeaf returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProcessExpressionLeaf} (expression="nil" |	expression="kill")
;

Guard hidden(ML_COMMENT,SL_COMMENT,WS):
	{Guard} "[" booleanExpression=BooleanExpression "]"
;

Action hidden(ML_COMMENT,SL_COMMENT,WS):
	{Action}
	name=ActionName
	(
		action=MultiCast | action=UniCast		
	)
;

MultiCast returns Cast hidden(ML_COMMENT,SL_COMMENT,WS):
	{MultiCast}
	"*" 
	(
		predicate=ActionGuard cast=IO | 
		cast=IO | 
		cast=SpontaneousAction
	)
;

UniCast returns Cast hidden(ML_COMMENT,SL_COMMENT,WS):
	{UniCast}
	(
		predicate=ActionGuard cast=IO |
		cast=IO
	)
;

IO hidden(ML_COMMENT,SL_COMMENT,WS):
	( 
		InputAction			|
		OutputAction
	)
;

SpontaneousAction returns IO hidden(ML_COMMENT,SL_COMMENT,WS):
	{SpontaneousAction} (update=Update)?
;

InputAction returns IO  hidden(ML_COMMENT,SL_COMMENT,WS):
	{InputAction}  inputActionArguments=InputActionArguments (update=Update)?
;

InputActionArguments hidden(ML_COMMENT,SL_COMMENT,WS):
	{InputActionArguments}
	"(" 
	(inputArguments+=VariableName
	( "," inputArguments+=VariableName )* )?
	")"
;

OutputAction returns IO hidden(ML_COMMENT,SL_COMMENT,WS):
	{OutputAction} outputActionArguments=OutputActionArguments (update=Update)?
;

OutputActionArguments hidden(ML_COMMENT,SL_COMMENT,WS):
	{OutputActionArguments}
	"<"
	(outputArguments+=OutputActionArgument
	( "," outputArguments+=OutputActionArgument )*)?
	">"
;

OutputActionArgument returns OutputActionArgument hidden(ML_COMMENT,SL_COMMENT,WS):
	(
		{OutputActionArgumentVR} 		ref=VariableReference 	|
		{OutputActionArgumentCI}		value=CarmaInteger
	)
;

Update hidden(ML_COMMENT,SL_COMMENT,WS):
	{Update} "{" (updateAssignment+=UpdateAssignment ( "," updateAssignment+=UpdateAssignment)*)? "}"
;


ActionGuard hidden(ML_COMMENT,SL_COMMENT,WS):
	{ActionGuard} "[" booleanExpression=BooleanExpression "]"
;


UpdateAssignment hidden(ML_COMMENT,SL_COMMENT,WS):
	{UpdateAssignment} storeReference=VariableReference ":=" expression=UpdateExpression
;

UpdateExpression returns UpdateExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{UpdateExpression} expression=UpdateSubtraction
;


UpdateSubtraction returns UpdateExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	UpdateAddition ({UpdateSubtraction.left=current} '-' 
		right=UpdateAddition
	)*
;

	
UpdateAddition returns UpdateExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	UpdateMultiplication ({UpdateAddition.left=current} '+' 
		right=UpdateMultiplication
	)*
;


UpdateMultiplication returns UpdateExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	UpdatePrimary ({UpdateMultiplication.left=current} '*' 
		right=UpdatePrimary
	)*
;


UpdatePrimary returns UpdateExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	'(' UpdateExpression ')' | 
	UpdateAtomic
;


UpdateAtomic returns UpdateExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{UpdateAtomicPrimitive}			value=PrimitiveType 			|
	{UpdateAtomicVariable}			value=VariableReference 		|
	{UpdateAtomicMethodReference}	value=MethodReference			
;
	
	
////////////////////////////////////////////////////BOOLEAN EXPRESSION
BooleanExpression returns BooleanExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{BooleanExpression} expression=BooleanOr
;

BooleanOr returns BooleanExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	BooleanAnd ({BooleanOr.left=current} "||" 
		right=BooleanAnd
	)*
;

BooleanAnd returns BooleanExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	BooleanEquality ({BooleanAnd.left=current} "&&" 
		right=BooleanEquality
	)*
;
	
BooleanEquality returns BooleanExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	BooleanComparison (
		{BooleanEquality.left=current} op=("=="|"!=")
		right=BooleanComparison
	)*
;

BooleanComparison returns BooleanExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	BooleanSubtraction ({BooleanComparison.left=current} op=(">="|"<="|">"|"<") 
		right=BooleanSubtraction
	)*
;

BooleanSubtraction returns BooleanExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	BooleanAddition ({BooleanSubtraction.left=current} '-' 
		right=BooleanAddition
	)*
;

BooleanAddition returns BooleanExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	BooleanMultiplication ({BooleanAddition.left=current} '+' 
		right=BooleanMultiplication
	)*
;

BooleanMultiplication returns BooleanExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	BooleanModulo ({BooleanMultiplication.left=current} '*' 
		right=BooleanModulo
	)*
;

BooleanModulo returns BooleanExpressions hidden(ML_COMMENT,SL_COMMENT,WS): 
	BooleanDivision ({BooleanModulo.left=current} '%' 
		right=BooleanDivision
	)*
;

BooleanDivision returns BooleanExpressions hidden(ML_COMMENT,SL_COMMENT,WS): 
	BooleanPrimary ({BooleanDivision.left=current} '/' 
		right=BooleanPrimary
	)*
;

BooleanPrimary returns BooleanExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	'(' BooleanExpression ')' | 
	{BooleanNot} "!" expression=BooleanPrimary |
	BooleanAtomic
;

BooleanAtomic returns BooleanExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{BooleanAtomicPrimitive}			value=PrimitiveType 			|
	{BooleanAtomicVariable}				value=VariableReference 		|
	{BooleanAtomicMethodReference}		value=MethodReference			|
	{BooleanAtomicNow}					value=Now		
;
////////////////////////////////////////////////////EXPRESSIONS
Expression returns Expressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{Expression} expression=Or
;

Or returns Expressions hidden(ML_COMMENT,SL_COMMENT,WS):
	And ({Or.left=current} "||" 
		right=And
	)*
;

And returns Expressions hidden(ML_COMMENT,SL_COMMENT,WS):
	Equality ({And.left=current} "&&" 
		right=Equality
	)*
;
	
Equality returns Expressions hidden(ML_COMMENT,SL_COMMENT,WS):
	Comparison (
		{Equality.left=current} op=("=="|"!=")
		right=Comparison
	)*
;

Comparison returns Expressions hidden(ML_COMMENT,SL_COMMENT,WS):
	Subtraction ({Comparison.left=current} op=(">="|"<="|">"|"<") 
		right=Subtraction
	)*
;

Subtraction returns Expressions hidden(ML_COMMENT,SL_COMMENT,WS):
	Addition ({Subtraction.left=current} '-' 
		right=Addition
	)*
;

Addition returns Expressions hidden(ML_COMMENT,SL_COMMENT,WS):
	Multiplication ({Addition.left=current} '+' 
		right=Multiplication
	)*
;

Multiplication returns Expressions hidden(ML_COMMENT,SL_COMMENT,WS):
	Modulo ({Multiplication.left=current} '*' 
		right=Modulo
	)*
;

Modulo returns Expressions hidden(ML_COMMENT,SL_COMMENT,WS): 
	Division ({Modulo.left=current} '%' 
		right=Division
	)*
;

Division returns Expressions hidden(ML_COMMENT,SL_COMMENT,WS): 
	Primary ({Division.left=current} '/' 
		right=Primary
	)*
;

Primary returns Expressions hidden(ML_COMMENT,SL_COMMENT,WS):
	'(' Expression ')' | 
	{Not} "!" expression=Primary |
	Atomic
;

Atomic returns Expressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{AtomicPrimitive}			value=PrimitiveType 	|
	{AtomicVariable}			value=VariableReference |
	{AtomicMethodReference}		value=MethodReference	|
	{AtomicNow}					value=Now				|
	{AtomicMeasure}				value=SetComp			|
	{AtomicMacro}				value=Macro				|
	{AtomicRecord}				value=RecordAsArgument	
;
////////////////////////////////////////////////////MEASURES

MeasureBlock returns MeasureBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	"measures" "{"
	measures+=Measure ";"
	(measures+=Measure+ ";")*
	"}"
;

Measure returns Measure hidden(ML_COMMENT,SL_COMMENT,WS):
	"measure" name=MeasureName parameters=MeasureVariableDeclarations "="  measure=SetComp 
;

MeasureVariableDeclarations hidden(ML_COMMENT,SL_COMMENT,WS):
	"["
	variables+=MeasureVariableDeclaration
	("," variables+=MeasureVariableDeclaration+)*
	"]"
;
	
////////////////////////////////////////////////////ENVIRONMENT	
	
Environment hidden(ML_COMMENT,SL_COMMENT,WS):
	{Environment}
	"environment" 
	"{"
	(stores=GlobalStoreBlock)?
	(probabilityBlock=ProbabilityBlock)?
	(rateBlock=RateBlock)?
	(updateBlock=UpdateBlock)?
	"}"
;

GlobalStoreBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{GlobalStoreBlock}
	"store" 
	"{" 
	(attributes+=StoreDeclaration ";"
	( attributes+=StoreDeclaration ";" )*)?
	"}"
;
	
ProbabilityBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProbabilityBlock}
	"prob" 
	"{"
		(probabilities+=Probability+ ";")*
		("default" ":" value=CarmaDouble ";")?
	"}"
;
	
Probability returns EnvironmentOperation hidden(ML_COMMENT,SL_COMMENT,WS):
	{Probability}
	guard=EnvironmentGuard stub=ActionStub ":" expression=EnvironmentExpression
;

RateBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{RateBlock}
	"rate"
	"{"
		(rates+=Rate+ ";")*
		("default" ":" value=CarmaDouble ";")?
	"}"
;

Rate returns EnvironmentOperation hidden(ML_COMMENT,SL_COMMENT,WS):
	{Rate}
	guard=EnvironmentGuard stub=ActionStub ":" expression=EnvironmentExpression
;
	
UpdateBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{UpdateBlock}
	"update"
	"{"
		(updates+=EnvironmentUpdate+ ";")*
	"}"
;

EnvironmentUpdate returns EnvironmentOperation hidden(ML_COMMENT,SL_COMMENT,WS):
	{EnvironmentUpdate}
	guard=EnvironmentGuard stub=ActionStub ":" 
	((expression+=EnvironmentUpdateAssignment ("," expression+=EnvironmentUpdateAssignment+)*)? 
	("," spawn=Spawn)? | spawn=Spawn)
;

EnvironmentUpdateAssignment hidden(ML_COMMENT,SL_COMMENT,WS):
	{EnvironmentUpdateAssignment} storeReference=VariableReference ":=" expression=EnvironmentUpdateExpression
;

EnvironmentGuard hidden(ML_COMMENT,SL_COMMENT,WS):
	{EnvironmentGuard} "[" booleanExpression=BooleanExpression "]"
;

ActionStub hidden(ML_COMMENT,SL_COMMENT,WS):
	{ActionStub} name=[ActionName|LOWERST](cast=MultiCastStub)?
;

MultiCastStub hidden(ML_COMMENT,SL_COMMENT,WS):
	"*"
;

IOStub hidden(ML_COMMENT,SL_COMMENT,WS):
	(in=InStub | out=OutStub)
;

InStub hidden(ML_COMMENT,SL_COMMENT,WS):
	"("")"
;

OutStub hidden(ML_COMMENT,SL_COMMENT,WS):
	"<"">"
;

EnvironmentExpression returns EnvironmentExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{EnvironmentExpression} expression=EnvironmentSubtraction
;

EnvironmentSubtraction returns EnvironmentExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	EnvironmentAddition ({EnvironmentSubtraction.left=current} '-' 
		right=EnvironmentAddition
	)*
;

EnvironmentAddition returns EnvironmentExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	EnvironmentMultiplication ({EnvironmentAddition.left=current} '+' 
		right=EnvironmentMultiplication
	)*
;
	
EnvironmentMultiplication returns EnvironmentExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	EnvironmentModulo ({EnvironmentMultiplication.left=current} '*' 
		right=EnvironmentModulo
	)*
;

EnvironmentModulo returns EnvironmentExpressions hidden(ML_COMMENT,SL_COMMENT,WS): 
	EnvironmentDivision ({EnvironmentModulo.left=current} '%' 
		right=EnvironmentDivision
	)*
;

EnvironmentDivision returns EnvironmentExpressions hidden(ML_COMMENT,SL_COMMENT,WS): 
	EnvironmentPrimary ({EnvironmentDivision.left=current} '/' 
		right=EnvironmentPrimary
	)*
;

EnvironmentPrimary returns EnvironmentExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	'(' EnvironmentExpression ')' | 
	EnvironmentAtomic
;
	
EnvironmentAtomic returns EnvironmentExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{EnvironmentAtomicPrimitive}			value=PrimitiveType 			|
	{EnvironmentAtomicVariable}				value=VariableReference 		|
	{EnvironmentAtomicMethodReference}		value=MethodReference			|
	{EnvironmentAtomicNow}					value=Now						|
	{EnvironmentAtomicMeasure}				value=SetComp
;
	
	
EnvironmentUpdateExpression returns EnvironmentUpdateExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{EnvironmentUpdateExpression} expression=EnvironmentUpdateSubtraction
;

EnvironmentUpdateSubtraction returns EnvironmentUpdateExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	EnvironmentUpdateAddition ({EnvironmentUpdateSubtraction.left=current} '-' 
		right=EnvironmentUpdateAddition
	)*
;

EnvironmentUpdateAddition returns EnvironmentUpdateExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	EnvironmentUpdateMultiplication ({EnvironmentUpdateAddition.left=current} '+' 
		right=EnvironmentUpdateMultiplication
	)*
;
	
EnvironmentUpdateMultiplication returns EnvironmentUpdateExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	EnvironmentUpdatePrimary ({EnvironmentUpdateMultiplication.left=current} '*' 
		right=EnvironmentUpdatePrimary
	)*
;

EnvironmentUpdatePrimary returns EnvironmentUpdateExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	'(' EnvironmentUpdateExpression ')' | 
	EnvironmentUpdateAtomic
;

EnvironmentUpdateAtomic returns EnvironmentUpdateExpressions hidden(ML_COMMENT,SL_COMMENT,WS):
	{EnvironmentUpdateAtomicPrimitive}				value=PrimitiveType 			|
	{EnvironmentUpdateAtomicVariable}				value=VariableReference 		|
	{EnvironmentUpdateAtomicMethodReference}		value=MethodReference			|
	{EnvironmentUpdateAtomicNow}					value=Now						|
	{EnvironmentUpdateAtomicMeasure}				value=SetComp
;

Now hidden(ML_COMMENT,SL_COMMENT,WS):
	"now"
;


terminal BOOLEANVALUE: 		('true' | 'false');
terminal LOWERST: 			("a".."z") ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal UPPERST: 			("A".."Z") ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;