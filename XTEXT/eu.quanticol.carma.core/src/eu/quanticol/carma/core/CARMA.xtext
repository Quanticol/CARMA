grammar eu.quanticol.carma.core.CARMA with org.eclipse.xtext.common.Terminals

generate carma "http://www.quanticol.eu/carma/core/CARMA"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


Model: {Model}
	(elements += Element)*
;

Element: 
	FunctionDefinition 
	| RecordDefinition 
	| Processes 
	| ConstantDefinition 
	| ComponentDefinition 
	| EnumDefinition
	| MeasureDefinition
	| SystemDefinition
	| ActivityDefinition
;

ActivityDefinition:
	name=LOWERST ':' '[' types += FieldType (',' types += FieldType )* ']' ';'	
;

////////////////////////////////////////////////////RECORDS, ENUMS AND TYPES

EnumDefinition:
	'enum' name=UPPERST '=' values += EnumCase (',' values += EnumCase ) ';'
;

RecordDefinition returns RecordDefinition hidden(ML_COMMENT,SL_COMMENT,WS):
	'record' name=UPPERST '=' '[' fields += FieldDefinition (','  fields += FieldDefinition)* ']' ';'
;

FieldDefinition:
	fieldType=FieldType name=LOWERST
;

ReferenceableType:
	EnumDefinition|RecordDefinition
;

EnumCase:
	name=UPPERST
;

ConstantDefinition:
	'const' name=LOWERST '=' value=Expression ';'
;

ValueType hidden(ML_COMMENT,SL_COMMENT,WS):
		{ProcessType} "process"	|
		FieldType
;

FieldType:
		{IntegerType} "int" |
		{RealType} "real" |
		{BooleanType} "bool" |
		{CustomType} reference=[ReferenceableType]
;

////////////////////////////////////////////////////VARIABLES AND REFERENCES

Variable:
	{IntegerParameter} "int" name=LOWERST
	| {RealParameter} "real" name=LOWERST
	| {BooleanParameter} "bool" name=LOWERST
	| {ProcessParameter} "process" name=UPPERST
	| {CustomParameter} reference=[ReferenceableType]  name=LOWERST
;

UntypedVariable:
	name=LOWERST
;

ReferenceableElement:
	UntypedVariable|Variable|AttributeDeclaration|FunctionDefinition|
	EnumCase|
	ConstantDefinition
;

////////////////////////////////////////////////////FUNCTIONS
FunctionDefinition:
	"fun" type=ValueType name=ID
	'('
	(parameters += Variable (',' parameters+=Variable)*)?
	')' '=' body=Expression ';'
;
	


////////////////////////////////////////////////////RANGES
Range returns PrimitiveTypes hidden(ML_COMMENT,SL_COMMENT,WS):
	{Range} min=INT ".." max=INT
;



//VariableReference returns VariableReference hidden(ML_COMMENT,SL_COMMENT,WS):
//	(
//		{VariableReferencePure} 					ref=[Variable] |
//		{VariableReferenceMy} 		"my" 		"." ref=[AttributeDeclaration] |
//		{VariableReferenceReceiver}	"receiver" 	"." ref=[AttributeDeclaration] |
//		{VariableReferenceSender}	"sender" 	"."	ref=[AttibuteVarDeclaration] |
//		{VariableReferenceGlobal}	"global"	"." ref=[AttributeDeclaration] |
//		{RecordReferencePure} 						ref=[Variable]
//		"." field=[FieldDefinition]	|
//		{RecordReferenceMy} 		"my" 		"." ref=[Variable]
//		"." field=[FieldDefinition]	|
//		{RecordReferenceReceiver}	"receiver" 	"." ref=[Variable]
//		"." field=[FieldDefinition]	|
//		{RecordReferenceSender}		"sender" 	"."	ref=[Variable]
//		"." field=[FieldDefinition] |
//		{RecordReferenceGlobal}		"global" 	"."	ref=[Variable]
//		"." field=[FieldDefinition]
//	)
//;

////////////////////////////////////////////////////ASSIGNMENT

UpdateAssignment returns Assignment hidden(ML_COMMENT,SL_COMMENT,WS):
	{UpdateAssignment} reference=[AttributeDeclaration] ":=" expression=Expression
;

////////////////////////////////////////////////////STATE

ProcessComposition returns ProcessComposition hidden(ML_COMMENT,SL_COMMENT,WS):
	ParallelComposition
; 
	
ParallelComposition returns ProcessComposition hidden(ML_COMMENT,SL_COMMENT,WS):
	ProcessReference ({ParallelComposition.left=current}  "|" right=ProcessReference)*
;

ProcessReference returns ProcessComposition hidden(ML_COMMENT,SL_COMMENT,WS):
	 {ProcessReference} expression=[Process]
;

////////////////////////////////////////////////////SET COMPREHENSION

SetComp hidden(ML_COMMENT,SL_COMMENT,WS):
	{SetComp} 
	"#" 
	"{" 
	variable=ComponentComprehension
	"|"
	predicate=Expression
	"}"
; 

////////////////////////////////////////////////////COMPONENT COMPREHENSION
ComponentComprehension returns ComponentComprehension hidden(ML_COMMENT,SL_COMMENT,WS):
	ParallelComponentComprehension
; 

ParallelComponentComprehension returns ComponentComprehension  hidden(ML_COMMENT,SL_COMMENT,WS):
	AtomicComponentComprehension ({ParallelComponentComprehension.left=current}  "&" right=AtomicComponentComprehension)*
;

AtomicComponentComprehension returns ComponentComprehension  hidden(ML_COMMENT,SL_COMMENT,WS):
	 {AllComponents} 		"*" 											|
	 {AComponentAllStates}	comp=[ComponentDefinition] "[" "*" "]"		|
	 {AComponentAState}		comp=[ComponentDefinition] "[" state=ProcessComposition "]" 
;

////////////////////////////////////////////////////SPAWN
Spawn hidden(ML_COMMENT,SL_COMMENT,WS):
	{Spawn} spawn=BlockSpawn
;

BlockSpawn hidden(ML_COMMENT,SL_COMMENT,WS):
	{BlockSpawn} comp+=ComponentBlockSpawn ("," comp+=ComponentBlockSpawn+)*
;

//////////////////////////////////////////////////////PREDEFINED METHODS	
//PreFunctionCall returns PreFunctionCall hidden(ML_COMMENT,SL_COMMENT,WS):
//	(	
//	{PDFunction} 		name="PDF"		| 
//	{UniformFunction} 	name="Uniform"	| 
//	{CeilingFunction} 	name="Ceiling"	|
//	{FloorFunction} 	name="Floor"	|
//	{MaxFunction}		name="Max"		|
//	{MinFunction}		name="Min"
//	)
//	arguments=PredFunctionCallArguments 
//;


////////////////////////////////////////////////////COMPONENT
ComponentDefinition hidden(ML_COMMENT,SL_COMMENT,WS):
	"component" name=UPPERST '(' (parameters += Variable (',' paramters +=Variable ))? ')'
	"{"
	store=StoreBlock
	processes=ProcessesBlock
	initBlock=InitBlock
	"}"
;

StoreBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{StoreBlock}
	"store" 
	"{" 
		(attributes+=AttributeDeclaration ";" )*
	"}"
;

AttributeDeclaration:
	{AttributeConstDeclaration} "const" name=LOWERST ":=" value=Expression
	| {AttibuteVarDeclaration} "attrib" name=LOWERST  ":=" value=Expression
;
	
ProcessesBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProcessesBlock}
	"behaviour"
	"{"
		(processes+=Process ";" )*
	"}"
;

InitBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{InitBlock}
	"init" 
	"{" 
		init=ProcessComposition
	"}"
;

BlockSystem returns System:
	{BlockSystem}
	"system" name=UPPERST "{"
	collective=BlockCollective
	(environment=Environment)?
	"}"
;

SystemDefinition:
	"system" name=UPPERST '{'
		'collective' '{'
			collective += ComponentBlockDeclaration ('||' collective+=ComponentBlockDeclaration)*			
		'}'
		(environment=Environment)?
		
	'}'
;

BlockCollective hidden(ML_COMMENT,SL_COMMENT,WS):
	"collective" "{"
		declarations+=ComponentBlockDeclaration ('||' declarations+=ComponentBlockDeclaration)
	"}"
;
	
ComponentBlockDeclaration hidden(ML_COMMENT,SL_COMMENT,WS):
	(  
		ComponentBlockNew |  
		ComponentBlockForStatement
	)
;
	
ComponentBlockNew returns CBND hidden(ML_COMMENT,SL_COMMENT,WS):
	{ComponentBlockNew}
	"new"
	name=[ComponentDefinition] 
	'(' (arguments+=Expression (',' arguments+=Expression)* )? ')'
//	("["population=INT"]")?
	";"
;

ComponentBlockSpawn returns CBND hidden(ML_COMMENT,SL_COMMENT,WS):
	{ComponentBlockSpawn}
	"new"
	name=[ComponentDefinition] 
	'(' (arguments+=Expression (',' arguments+=Expression)* )? ')'
//	("["population=INT"]")?
;

ComponentBlockForStatement hidden(ML_COMMENT,SL_COMMENT,WS):
	"for" "(" variable=LOWERST ";" expression=Expression ";" afterThought=Expression ")" '{'
			collective += ComponentBlockDeclaration ('||' collective+=ComponentBlockDeclaration)*			
	'}'
;

////////////////////////////////////////////////////PROCESS
Processes hidden(ML_COMMENT,SL_COMMENT,WS): {Processes}
	"abstract" "{"
		( processes+=Process ";" )*
	"}"
;

Process hidden(ML_COMMENT,SL_COMMENT,WS):
	name=UPPERST
	"="
	processExpression=ProcessExpression 
;

ProcessExpression returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	ProcessExpressionChoice
;

ProcessExpressionChoice returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	ProcessExpressionGuard ({ProcessExpressionChoice.left=current}  "+" right=ProcessExpressionGuard)*
;

ProcessExpressionGuard returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProcessExpressionGuard} guard=Guard expression=ProcessExpressionGuard
	| ProcessExpressionPrimary
;

ProcessExpressionPrimary returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	"(" ProcessExpression ")" |
	ProcessExpressionAction
;

ProcessExpressionAction hidden(ML_COMMENT,SL_COMMENT,WS):
	action=Action "." next=ProcessExpressionNext	
;

ProcessExpressionNext:
		{ProcessExpressionNil} "nil"
	| {ProcessExpressionKill} "kill"
	| {ProcessExpressionReference} expression=[Process]
;

Guard hidden(ML_COMMENT,SL_COMMENT,WS):
	"[" booleanExpression=Expression "]"
;

Activity:
	reference=[ActivityDefinition] (isBroadacst?='*')? (predicate=ActionGuard)? 	
;

Action hidden(ML_COMMENT,SL_COMMENT,WS):
	Activity (
		{OutputAction.activity=current} 
			("<" (outputArguments+=Expression ( "," outputArguments+=Expression )*)? ">")? 
			(update=Update)?
		| {InputAction.activity=current} 
			"(" 
				(parameters+=UntypedVariable
				( "," parameters+=UntypedVariable )* )?
			")"
			(update=Update)?
	)
;

//IO hidden(ML_COMMENT,SL_COMMENT,WS):
//	( 
//		InputAction			|
//		OutputAction
//	)
//;
//
//InputAction returns IO  hidden(ML_COMMENT,SL_COMMENT,WS):
//	{InputAction}  "(" 
//	(parameters+=UntypedVariable
//	( "," parameters+=UntypedVariable )* )?
//	")"
//;
//
//OutputAction returns IO hidden(ML_COMMENT,SL_COMMENT,WS):
//	{OutputAction} "<"
//	(outputArguments+=Expression
//	( "," outputArguments+=Expression )*)?
//	">"
//;



Update hidden(ML_COMMENT,SL_COMMENT,WS):
	{Update} "{" (updateAssignment+=UpdateAssignment ( "," updateAssignment+=UpdateAssignment)*)? "}"
;

ActionGuard hidden(ML_COMMENT,SL_COMMENT,WS):
	{ActionGuard} "[" guard=Expression "]"
;
////////////////////////////////////////////////////Expression
Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	Or
;

Or returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	And ({Or.left=current} "||" 
		right=And
	)*
;

And returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	Equality ({And.left=current} "&&" 
		right=Equality
	)*
;
	
Equality returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	SumDiff (
		{Equality.left=current} '==' right=SumDiff
		| {DisEquality.left=current} '!=' right=SumDiff
		| {Less.left=current} '<' right=SumDiff
		| {LessOrEqual.left=current} '<=' right=SumDiff
		| {Greater.left=current} '>' right=SumDiff
		| {GreaterOrEqual.left=current} '>=' right=SumDiff
	)?
;

SumDiff returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	MulDiv (
		{Subtraction.left=current} '-' right=MulDiv
		| {Addition.left=current} '+' right=MulDiv
	)*
;

MulDiv returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	Modulo ({Multiplication.left=current} '*' right=Modulo
		| {Division.left=current} '/' right=Modulo
	)*
;

Modulo returns Expression hidden(ML_COMMENT,SL_COMMENT,WS): 
	Primary ({Modulo.left=current} '%' 
		right=Primary
	)?
;

Primary returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	'(' Expression 	({IfThenElseExpression.guard=current} "?" thenBranch=Expression ":" elseBranch=Expression)? ")" | 
	{Not} "!" expression=Primary |
	{UnaryPlus} '+' expression=Primary |
	{UnaryMinus} '-' expression=Primary | 
	Atomic	
;



Atomic returns Expression hidden(ML_COMMENT,SL_COMMENT,WS):
	ReferenceToSymbol 
	| {AtomicTrue} "true"
	| {AtomicFalse} "false"
	| {AtomicInteger} value=INT 
	| {AtomicReal} value=REAL 
	| {AtomicRecord} '[' fields += FieldAssignment (',' fields += FieldAssignment)* ']' 
	| {AtomicNow} "now" 
	| SetComp				
	| {AtomicRnd} "RND"
	| {AtomicPi} "PI"
	| {AtomicExp} "E"
	| BuiltInFunctions
	| {MyContext} "my" "." reference=ReferenceToSymbol
	| {ReceiverContext} "recever" "." reference=ReferenceToSymbol
	| {SenderContext} "sender" "." reference=ReferenceToSymbol
	| {GlobalContext} "global" "." reference=ReferenceToSymbol
//	| {AtomicOutcome}				value=OutcomeProbability	THE ROLE OF THIS CASES IS NOT CLEAR FOR ME.
//	| {AtomicProcessComposition}	value=ProcessComposition
;

BuiltInFunctions returns Expression :
	{AbsFunction} "abs" '(' arg=Expression ')' 
			//The absolute value of arg.
	| {AcosFunction} "acos" '(' arg=Expression ')' 
			//The arc cosine of arg; the returned angle is in the range 0.0 through pi.
	| {AsinFunction} "asin" '(' arg=Expression ')' 
			//The arc sine of a value; the returned angle is in the range -pi/2 through pi/2.
	| {AtanFunction} "atan" '(' arg=Expression ')' 
			//Returns the arc tangent arg; the returned angle is in the range -pi/2 through pi/2.
	| {Atan2Function} "atan2" '(' first=Expression ',' second=Expression ')'
			//The angle theta from the conversion of rectangular coordinates (first, second) to polar coordinates (r, theta).
	| {CbrtFunction} "cbrt" '(' arg=Expression ')'
			//The cube root of arg.
	| {CeilFunction} "ceil" '(' arg=Expression ')'
			//The smallest (closest to negative infinity) double value that is greater than or equal to the argument and is equal to a mathematical integer.
	| {CosFunction} "cos" '(' arg=Expression ')'
			//Returns the trigonometric cosine of an angle.
	| {ExpFunction} "exp" '(' arg=Expression ')'
			//Returns Euler's number e raised to the power of a double value.
	| {FloorFunction} "floor" '(' arg=Expression ')'
			//Returns the largest (closest to positive infinity) double value that is less than or equal to the argument and is equal to a mathematical integer.
	| {LogFunction} "log" '(' arg=Expression ')'
			//Returns the natural logarithm (base e) of a double value.
	| {Log10Function} "log10" '(' arg=Expression ')'
			//Returns the base 10 logarithm of a double value.
	| {MaxFunction} "max" '(' first=Expression ',' second=Expression ')'
	| {MinFunction} "min" '(' first=Expression ',' second=Expression ')'
	| {PowFunction} "pow" '(' first=Expression ',' second=Expression ')'
	| {SinFunction} "sin" '(' arg=Expression ')'
			//Returns the trigonometric sine of an angle.
	| {SqrtFunction} "sqrt" '(' arg=Expression ')'
			//Returns the correctly rounded positive square root of a double value.
	| {TanFunction} "tan" '(' arg=Expression ')'
			//Returns the trigonometric tangent of an angle.
	| {UniformFunction} "U" '(' args+=Expression (',' args+=Expression)* ')' 
;

FieldAssignment:
	field=[FieldDefinition] ':=' value=Expression
;

////////////////////////////////////////////////////REFERENCE


ReferenceToSymbol:
	VariableReference (
		{RecordAccess.source=current} '.' field=[FieldDefinition]
		| {Call.source=current} '(' ( args+=Expression ( ',' args+=Expression )* )? ')'
	)?
;

VariableReference hidden(ML_COMMENT,SL_COMMENT,WS):
	reference=[ReferenceableElement] 
;

////////////////////////////////////////////////////MEASURES

MeasureDefinition hidden(ML_COMMENT,SL_COMMENT,WS):
	"measure" name=UPPERST (ranges=MeasureVariableDeclarations)? "="  measure=Expression  ';'
;

MeasureVariableDeclarations hidden(ML_COMMENT,SL_COMMENT,WS):
	"["
	variables+=MeasureVariableDeclaration
	("," variables+=MeasureVariableDeclaration+)*
	"]"
;

MeasureVariableDeclaration hidden(ML_COMMENT,SL_COMMENT,WS):
	{MeasureVariableDeclaration} name=LOWERST	":="	assign=(
		Range |
		Expression
	)
;

	
////////////////////////////////////////////////////ENVIRONMENT	
Environment hidden(ML_COMMENT,SL_COMMENT,WS):
	{Environment}
	"environment" 
	"{"
	(stores=StoreBlock)?
	(probabilityBlock=ProbabilityBlock)?
	(rateBlock=RateBlock)?
	(updateBlock=UpdateBlock)?
	"}"
;

ProbabilityBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{ProbabilityBlock}
	"prob" 
	"{"
		(probabilities+=Probability ";")*
		("default" ":" value=Expression ";")?
	"}"
;
	
Probability hidden(ML_COMMENT,SL_COMMENT,WS):
	guard=Guard stub=ActionStub ":" expression=Expression
;

RateBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{RateBlock}
	"rate"
	"{"
		(rates+=Rate+ ";")*
		("default" ":" value=Expression ";")?
	"}"
;

Rate hidden(ML_COMMENT,SL_COMMENT,WS):
	{Rate}
	guard=Guard stub=ActionStub ":" expression=Expression
;
	
UpdateBlock hidden(ML_COMMENT,SL_COMMENT,WS):
	{UpdateBlock}
	"update"
	"{"
		(updates+=EnvironmentUpdate+ ";")*
	"}"
;

EnvironmentUpdate returns EvolutionRule hidden(ML_COMMENT,SL_COMMENT,WS):
	{EnvironmentUpdate}
	guard=Guard stub=ActionStub ":" 
	((update+=UpdateAssignment ("," expression+=UpdateAssignment+)*)? 
	("," spawn=Spawn)? | spawn=Spawn)
;

ActionStub hidden(ML_COMMENT,SL_COMMENT,WS):
	{ActionStub} name=[Action] (isBroadcast?='*')?
;


terminal LOWERST: 			("a".."z") ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal UPPERST: 			("A".."Z") ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal REAL returns ecore::EDouble: (('0'..'9')+ '.' ('0' .. '9')*)|('.'('0' .. '9')*);
