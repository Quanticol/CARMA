/*
 * generated by Xtext
 */
package eu.quanticol.carma.core.scoping

import eu.quanticol.carma.core.carma.ComponentDefinition
import eu.quanticol.carma.core.carma.AttributeDeclaration
import static extension org.eclipse.xtext.EcoreUtil2.*
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.emf.ecore.EObject
import eu.quanticol.carma.core.carma.FunctionDefinition
import org.eclipse.emf.ecore.EReference
import eu.quanticol.carma.core.carma.Model
import eu.quanticol.carma.core.carma.RecordAccess
import eu.quanticol.carma.core.carma.ConstantDefinition
import org.eclipse.xtext.scoping.IScope
import eu.quanticol.carma.core.carma.SystemDefinition
import eu.quanticol.carma.core.carma.ReferenceableElement
import eu.quanticol.carma.core.carma.Element
import eu.quanticol.carma.core.carma.StoreBlock
import eu.quanticol.carma.core.carma.MeasureDefinition
import static extension eu.quanticol.carma.core.typing.TypeSystem.*
import eu.quanticol.carma.core.carma.RecordDefinition
import eu.quanticol.carma.core.carma.ProcessesBlock
import eu.quanticol.carma.core.carma.MyContext
import eu.quanticol.carma.core.carma.GlobalContext
import eu.quanticol.carma.core.carma.Environment
import eu.quanticol.carma.core.carma.SenderContext
import eu.quanticol.carma.core.carma.ReceiverContext
import eu.quanticol.carma.core.carma.InputAction
import eu.quanticol.carma.core.carma.Processes
import eu.quanticol.carma.core.carma.AtomicRecord
import eu.quanticol.carma.core.utils.Util
import com.google.inject.Inject
import eu.quanticol.carma.core.typing.TypeSystem
import eu.quanticol.carma.core.carma.AllComponents
import eu.quanticol.carma.core.carma.AComponentAState
import eu.quanticol.carma.core.carma.ComponentBlockInstantiation
import eu.quanticol.carma.core.carma.ComponentBlockForStatement
import java.util.LinkedList
import eu.quanticol.carma.core.carma.EnumDefinition
import eu.quanticol.carma.core.carma.BlockCommand
import eu.quanticol.carma.core.carma.FunctionCommand
import eu.quanticol.carma.core.carma.IfThenElseCommand
import eu.quanticol.carma.core.carma.ForCommand
import eu.quanticol.carma.core.carma.VariableDeclarationCommand
import eu.quanticol.carma.core.carma.AssignmentCommand
import eu.quanticol.carma.core.carma.ProcessState
import eu.quanticol.carma.core.carma.TargetAssignmentField

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class CARMAScopeProvider extends org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider {

	@Inject extension Util
	@Inject extension TypeSystem



	def dispatch IScope getScopeFor( BlockCommand container , FunctionCommand command ) {
		var idx = container.commands.indexOf(command)	
		if (idx<=0) {
			container.parentScope
		} else {
			var localVariables = container.commands.subList(0,idx).filter(typeof(VariableDeclarationCommand)).map[it.variable]					
			if (localVariables.size > 0) {
				Scopes::scopeFor( localVariables , container.parentScope )
			} else {
				container.parentScope
			}
		}
	}

	def dispatch getScopeFor( IfThenElseCommand container , FunctionCommand command ) {
		container.parentScope	
	}

	def dispatch getScopeFor( ForCommand container , FunctionCommand command ) {
		Scopes::scopeFor( newLinkedList( container.variable ) , container.parentScope )
	}
	
	def IScope parentScope( FunctionCommand c ) {
		var parent = c.eContainer
		switch( parent ) {
			FunctionCommand: parent.getScopeFor(c)
			FunctionDefinition: Scopes::scopeFor( 
				parent.parameters , 
				Scopes::scopeFor( 
					parent.globalReferenceableElements.filter[
						it.isValidInExpressions
					]	  				
				)
			)
			default: IScope::NULLSCOPE
		}
	}
	
	def isValidInExpressions( ReferenceableElement r ) {
		!((r instanceof AttributeDeclaration)||(r instanceof ProcessState))
	}


	def scope_AssignmentTargetVariable_variable( AssignmentCommand c , EReference r ) {
		c.parentScope
	}

	def scope_Reference_reference( FunctionCommand c , EReference r ) {
		c.parentScope
	}

	def scope_Reference_reference( AttributeDeclaration a , EReference r) {
		var element = a.getContainerOfType(typeof(Element))
		var globalReferences = element.globalReferenceableElements.filter[ it.isValidInExpressions ]
		var parentScope = Scopes::scopeFor( globalReferences )
		if (element instanceof ComponentDefinition) {
			parentScope = Scopes::scopeFor( element.parameters , parentScope )			
		}
		var block = a.getContainerOfType(typeof(StoreBlock))
		if (block != null) {
			var idx = block.attributes.indexOf(a)
			if (idx > 0) {
				Scopes::scopeFor( block.attributes.subList(0,idx) , 
					parentScope )
			} else {
				parentScope
			}						
		} else {
				parentScope
		}
	}
	
	def scope_Reference_reference( ProcessesBlock a , EReference r) {
		var comp = a.getContainerOfType(typeof(ComponentDefinition))
		if (comp != null) {
			var globalReferences = comp.globalReferenceableElements.filter[it.validInExpressions]
			if (comp.store != null) {
				Scopes::scopeFor( 
					comp.store.attributes , 
					Scopes::scopeFor( globalReferences)
				)
			} else {
				Scopes::scopeFor( globalReferences )
			}			
		} else {
			IScope::NULLSCOPE		
		}
	}

	def scope_Reference_reference( Processes a , EReference r) {
		var m = a.getContainerOfType(typeof(Model))
		if (m != null) {
			var parentScope = a.globalReferenceableElements.filter[ !(it instanceof ProcessState) ]
			Scopes::scopeFor( m.attributes  , Scopes::scopeFor( parentScope ) )
		} else {
			IScope::NULLSCOPE		
		}
	}
	
	def scope_AttributeDeclaration( MyContext a , EReference r ) {
		var comp = a.getContainerOfType(typeof(ComponentDefinition))
		if (comp != null) {
			Scopes::scopeFor( comp.store.attributes )
		} else {
			var model = a. getContainerOfType(typeof(Model))
			if (model != null) {
				Scopes::scopeFor( model.attributes )
			} else {
				IScope::NULLSCOPE			
			}
		}
	}
	
	def scope_Reference_reference( InputAction a , EReference r ) {
		var comp = a.getContainerOfType(typeof(ComponentDefinition))
		if (comp != null) {
			Scopes::scopeFor( a.parameters , scope_Reference_reference(comp.processes,r) )
		} else {
			var prcs = a.getContainerOfType(typeof(Processes))
			if (prcs != null) {
				Scopes::scopeFor( a.parameters , scope_Reference_reference(prcs,r) )
			} else {
				IScope::NULLSCOPE
			}
		}
	}

	def scope_AttributeDeclaration( GlobalContext a , EReference r ) {
		var env = a.getContainerOfType(typeof(Environment))
		if (env != null) { //This is an access to the global store performed in the environment
			if (env.store != null) {
				Scopes::scopeFor( env.store.attributes )
			} else {
				IScope::NULLSCOPE
			}
		} else {
			var mes = a.getContainerOfType(typeof(MeasureDefinition))
			if (mes != null) {//This is an access to the global store performed in a measure
				Scopes::scopeFor( a.getContainerOfType(typeof(Model)).globalAttributes)			
			} else {
				IScope::NULLSCOPE			
			}
		}
	}

	def scope_AttributeDeclaration( SenderContext a , EReference r ) {
		var env = a.getContainerOfType(typeof(Environment))
		if (env != null) { 
			var model = env.getContainerOfType(typeof(Model))
			if (model != null) {
				Scopes::scopeFor( model.attributes )
			} else {
				IScope::NULLSCOPE
			}
		} else {
			IScope::NULLSCOPE			
		}
	}

	def scope_AttributeDeclaration( ReceiverContext a , EReference r ) {
		var env = a.getContainerOfType(typeof(Environment))
		if (env != null) { 
			var model = env.getContainerOfType(typeof(Model))
			if (model != null) {
				Scopes::scopeFor( model.attributes )
			} else {
				IScope::NULLSCOPE
			}
		} else {
			IScope::NULLSCOPE			
		}
	}

	def scope_FieldDefinition( TargetAssignmentField record , EReference r ) {
		if (record.target == null) {
			IScope::NULLSCOPE
		} else {
			var type = record.target.typeOf
			if (type.isRecord) {
				Scopes::scopeFor( (type.reference as RecordDefinition).fields )
			} else {
				IScope::NULLSCOPE
			}
		}
	}

	def scope_FieldDefinition( RecordAccess record , EReference r ) {
		if (record.source==null) {
			IScope::NULLSCOPE
		} else {
			var type = record.source.typeOf
			if (type.isRecord) {
				Scopes::scopeFor( (type.reference as RecordDefinition).fields )
			} else {
				IScope::NULLSCOPE
			}
		}
	}
	

//	def scope_Reference_reference( Element e , EReference r) {
//		e.referenceableElementScopeForElement
//	}
	
	def scope_FieldAssignment_field( AtomicRecord record , EReference r ) {
		var model = record.getContainerOfType(typeof(Model))
		if (model != null) {
			Scopes::scopeFor( model.fields )
		} else {
			IScope::NULLSCOPE
		}
	}
	
	def scope_UpdateAssignment_reference( Processes p , EReference r ) {
		var model = p.getContainerOfType(typeof(Model)) 
		if (model != null) {
			Scopes::scopeFor( model.attributes )
		} else {
			IScope::NULLSCOPE
		}		
	}
	

	def scope_ProcessExpressionReference_expression( Processes p ,EReference r ) {
		Scopes::scopeFor( p.processes )
	}

	def scope_ProcessReference_expression( AllComponents all ,EReference r ) {
		var model = all.getContainerOfType(typeof(Model))
		Scopes::scopeFor(model.allProcesses)
	}

	def scope_ProcessReference_expression( AComponentAState acas ,EReference r ) {
		var model = acas.getContainerOfType(typeof(Model))
		var procs = model.globalProcesses
		if (acas.comp != null) {
			procs = acas.comp.processes.processes+procs 
		} 
		Scopes::scopeFor(procs)
	}

	def scope_ProcessReference_expression( ComponentDefinition c ,EReference r ) {
		var outer = c.parameters.filter[ it.typeOf.process ]
		var processes = c.processes.processes 
		Scopes::scopeFor( processes , Scopes::scopeFor( outer ) )
	}

//	def dispatch getReferenceableElementScopeForElement( FunctionDefinition f ) {
//		if ( f != null ) {
//			Scopes::scopeFor( f.parameters , f.referenceableElements )
//		} else {
//			IScope::NULLSCOPE
//		}
//	}
//
//	def dispatch getReferenceableElementScopeForElement( ComponentDefinition c ) {
//		if ( c != null ) {
//			Scopes::scopeFor( c.parameters.filter[ !it.typeOf.process ] , c.referenceableElements )
//		} else {
//			IScope::NULLSCOPE
//		}
//	}
//	
//	def dispatch getReferenceableElementScopeForElement( MeasureDefinition m ) {
//		if ( m != null ) {
//			var parentScope = m.referenceableElements
//			var model = m.getContainerOfType(typeof(Model))
//			if (model != null) {
//				parentScope = Scopes::scopeFor( model.attributes , parentScope )
//			}			
//			Scopes::scopeFor( m.variables , parentScope )
//		} else {
//			IScope::NULLSCOPE
//		}
//	}
//
//	def dispatch getReferenceableElementScopeForElement( SystemDefinition m ) {
//		if ( m != null ) {
//			m.referenceableElements 
//		} else {
//			IScope::NULLSCOPE
//		}
//	}
	
	
	def Iterable<? extends ReferenceableElement> getGlobalReferenceableElementsProvided( Element e ) {
		switch e {
			FunctionDefinition:  newLinkedList( e )
			Processes: e.processes 
			ConstantDefinition: newLinkedList( e )			
			EnumDefinition: e.values
			SystemDefinition: e.environment.store.attributes
			default: newLinkedList()			
		}
	}
	
	def getGlobalReferenceableElements( Element e ) {
		var model = e.getContainerOfType(typeof(Model))
		if (model != null) {
			model.elements.map[it.globalReferenceableElementsProvided].flatten
		} else {
			newLinkedList()
		}
	}
	
	def scope_ActionStub_activity( SystemDefinition sys ,EReference r ) {
		var model = sys.getContainerOfType(typeof(Model))
		if (model != null) {
			Scopes::scopeFor( model.activities )
		} else {
			IScope::NULLSCOPE
		}
	}
	
	def getContainerScope( EObject cbi ) {
		var forVariables = newLinkedList()
		var parent = cbi.getContainerOfType(typeof(ComponentBlockForStatement))
		while ( parent != null ) {
			forVariables.add( parent.variable )
			parent = parent.eContainer ?. getContainerOfType(typeof(ComponentBlockForStatement))
		}
		var sys = cbi.getContainerOfType(typeof(SystemDefinition)).globalReferenceableElements.filter[ 
			!( it instanceof AttributeDeclaration)
		]
		Scopes::scopeFor( forVariables , Scopes::scopeFor( sys ) )
	}
	
	def scope_Reference_reference( ComponentBlockInstantiation cbi , EReference r ) {
		var parentScope = cbi.containerScope
		var comp = cbi.name
		if (comp != null) {
			Scopes::scopeFor( comp.processes.processes , parentScope )
		} else {
			parentScope
		}
	}
	
	def scope_Reference_reference( ComponentBlockForStatement forBlock , EReference r ) {
		var parentScope = forBlock.containerScope
		Scopes::scopeFor( newLinkedList( forBlock.variable ) , parentScope )
	}
	

}
