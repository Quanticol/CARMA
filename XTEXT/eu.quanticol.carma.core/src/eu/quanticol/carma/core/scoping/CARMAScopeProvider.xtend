/*
 * generated by Xtext
 */
package eu.quanticol.carma.core.scoping

import eu.quanticol.carma.core.carma.ComponentDefinition
import eu.quanticol.carma.core.carma.AttributeDeclaration
import static extension org.eclipse.xtext.EcoreUtil2.*
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.emf.ecore.EObject
import eu.quanticol.carma.core.carma.FunctionDefinition
import org.eclipse.emf.ecore.EReference
import eu.quanticol.carma.core.carma.Model
import eu.quanticol.carma.core.carma.RecordAccess
import eu.quanticol.carma.core.carma.ConstantDefinition
import org.eclipse.xtext.scoping.IScope
import eu.quanticol.carma.core.carma.SystemDefinition
import eu.quanticol.carma.core.carma.ReferenceableElement
import eu.quanticol.carma.core.carma.Element
import eu.quanticol.carma.core.carma.StoreBlock
import eu.quanticol.carma.core.carma.MeasureDefinition
import static extension eu.quanticol.carma.core.typing.TypeSystem.*
import eu.quanticol.carma.core.carma.RecordDefinition
import eu.quanticol.carma.core.carma.ProcessesBlock
import eu.quanticol.carma.core.carma.MyContext
import eu.quanticol.carma.core.carma.GlobalContext
import eu.quanticol.carma.core.carma.Environment
import eu.quanticol.carma.core.carma.SenderContext
import eu.quanticol.carma.core.carma.ReceiverContext
import eu.quanticol.carma.core.carma.InputAction
import eu.quanticol.carma.core.carma.Processes
import eu.quanticol.carma.core.carma.AtomicRecord
import eu.quanticol.carma.core.utils.Util
import com.google.inject.Inject
import eu.quanticol.carma.core.typing.TypeSystem
import eu.quanticol.carma.core.carma.AllComponents
import eu.quanticol.carma.core.carma.AComponentAState
import eu.quanticol.carma.core.carma.ComponentBlockInstantiation
import eu.quanticol.carma.core.carma.ComponentBlockForStatement
import java.util.LinkedList
import eu.quanticol.carma.core.carma.EnumDefinition

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class CARMAScopeProvider extends org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider {

	@Inject extension Util
	@Inject extension TypeSystem

	def scope_Reference_reference( AttributeDeclaration a , EReference r) {
		var parentScope = a.getContainerOfType(typeof(Element)).referenceableElementScopeForElement
		var block = a.getContainerOfType(typeof(StoreBlock))
		if (block != null) {
			var idx = block.attributes.indexOf(a)
			if (idx > 0) {
				Scopes::scopeFor( block.attributes.subList(0,idx) , parentScope )
			} else {
				parentScope
			}						
		} else {
			parentScope
		}
	}
	
	def scope_Reference_reference( ProcessesBlock a , EReference r) {
		var comp = a.getContainerOfType(typeof(ComponentDefinition))
		if (comp != null) {
			var parentScope = comp.referenceableElementScopeForElement
			if (comp.store != null) {
				Scopes::scopeFor( comp.store.attributes , parentScope )
			} else {
				parentScope
			}			
		} else {
			IScope::NULLSCOPE		
		}
	}

	def scope_Reference_reference( Processes a , EReference r) {
		var m = a.getContainerOfType(typeof(Model))
		if (m != null) {
			var parentScope = a.referenceableElementScopeForElement
			Scopes::scopeFor( m.attributes  , parentScope )
		} else {
			IScope::NULLSCOPE		
		}
	}
	
	def scope_AttributeDeclaration( MyContext a , EReference r ) {
		var comp = a.getContainerOfType(typeof(ComponentDefinition))
		if (comp != null) {
			Scopes::scopeFor( comp.store.attributes )
		} else {
			var model = a. getContainerOfType(typeof(Model))
			if (model != null) {
				Scopes::scopeFor( model.attributes )
			} else {
				IScope::NULLSCOPE			
			}
		}
	}
	
	def scope_Reference_reference( InputAction a , EReference r ) {
		var comp = a.getContainerOfType(typeof(ComponentDefinition))
		if (comp != null) {
			Scopes::scopeFor( a.parameters , scope_Reference_reference(comp.processes,r) )
		} else {
			var prcs = a.getContainerOfType(typeof(Processes))
			if (prcs != null) {
				Scopes::scopeFor( a.parameters , scope_Reference_reference(prcs,r) )
			} else {
				IScope::NULLSCOPE
			}
		}
	}

	def scope_AttributeDeclaration( GlobalContext a , EReference r ) {
		var env = a.getContainerOfType(typeof(Environment))
		if (env != null) { //This is an access to the global store performed in the environment
			if (env.store != null) {
				Scopes::scopeFor( env.store.attributes )
			} else {
				IScope::NULLSCOPE
			}
		} else {
			var mes = a.getContainerOfType(typeof(MeasureDefinition))
			if (mes != null) {//This is an access to the global store performed in a measure
				Scopes::scopeFor( a.getContainerOfType(typeof(Model)).globalAttributes)			
			} else {
				IScope::NULLSCOPE			
			}
		}
	}

	def scope_AttributeDeclaration( SenderContext a , EReference r ) {
		var env = a.getContainerOfType(typeof(Environment))
		if (env != null) { //This is an access to the global store performed in the environment
			var model = env.getContainerOfType(typeof(Model))
			if (model != null) {
				Scopes::scopeFor( model.attributes )
			} else {
				IScope::NULLSCOPE
			}
		} else {
			IScope::NULLSCOPE			
		}
	}

	def scope_AttributeDeclaration( ReceiverContext a , EReference r ) {
		var env = a.getContainerOfType(typeof(Environment))
		if (env != null) { //This is an access to the global store performed in the environment
			var model = env.getContainerOfType(typeof(Model))
			if (model != null) {
				Scopes::scopeFor( model.attributes )
			} else {
				IScope::NULLSCOPE
			}
		} else {
			IScope::NULLSCOPE			
		}
	}

	def scope_FieldDefinition( RecordAccess record , EReference r ) {
		if (record.source==null) {
			IScope::NULLSCOPE
		} else {
			var type = record.source.typeOf
			if (type.isRecord) {
				Scopes::scopeFor( (type.reference as RecordDefinition).fields )
			} else {
				IScope::NULLSCOPE
			}
		}
	}

	def scope_Reference_reference( Element e , EReference r) {
		e.referenceableElementScopeForElement
	}
	
	def scope_FieldAssignment_field( AtomicRecord record , EReference r ) {
		var model = record.getContainerOfType(typeof(Model))
		if (model != null) {
			Scopes::scopeFor( model.fields )
		} else {
			IScope::NULLSCOPE
		}
	}
	
	def scope_UpdateAssignment_reference( Processes p , EReference r ) {
		var model = p.getContainerOfType(typeof(Model)) 
		if (model != null) {
			Scopes::scopeFor( model.attributes )
		} else {
			IScope::NULLSCOPE
		}		
	}
	

	def scope_ProcessExpressionReference_expression( Processes p ,EReference r ) {
		Scopes::scopeFor( p.processes )
	}

	def scope_ProcessReference_expression( AllComponents all ,EReference r ) {
		var model = all.getContainerOfType(typeof(Model))
		Scopes::scopeFor(model.allProcesses)
	}

	def scope_ProcessReference_expression( AComponentAState acas ,EReference r ) {
		var model = acas.getContainerOfType(typeof(Model))
		var procs = model.globalProcesses
		if (acas.comp != null) {
			procs = acas.comp.processes.processes+procs 
		} 
		Scopes::scopeFor(procs)
	}

	def scope_ProcessReference_expression( ComponentDefinition c ,EReference r ) {
		var outer = c.parameters.filter[ it.typeOf.process ]
		var processes = c.processes.processes 
		Scopes::scopeFor( processes , Scopes::scopeFor( outer ) )
	}

	def dispatch getReferenceableElementScopeForElement( FunctionDefinition f ) {
		if ( f != null ) {
			Scopes::scopeFor( f.parameters , f.referenceableElementsBefore )
		} else {
			IScope::NULLSCOPE
		}
	}

	def dispatch getReferenceableElementScopeForElement( ComponentDefinition c ) {
		if ( c != null ) {
			Scopes::scopeFor( c.parameters.filter[ !it.typeOf.process ] , c.referenceableElementsBefore )
		} else {
			IScope::NULLSCOPE
		}
	}
	
	def dispatch getReferenceableElementScopeForElement( MeasureDefinition m ) {
		if ( m != null ) {
			var parentScope = m.referenceableElementsBefore
			var model = m.getContainerOfType(typeof(Model))
			if (model != null) {
				parentScope = Scopes::scopeFor( model.attributes , parentScope )
			}			
			Scopes::scopeFor( m.variables , parentScope )
		} else {
			IScope::NULLSCOPE
		}
	}

	def dispatch getReferenceableElementScopeForElement( SystemDefinition m ) {
		if ( m != null ) {
			m.referenceableElementsBefore 
		} else {
			IScope::NULLSCOPE
		}
	}
	
	
	def addReferenceableElements( Element e , LinkedList<ReferenceableElement> references ) {
		switch e {
			FunctionDefinition:  references.add(e)
			Processes: references.addAll( e.processes )
			ConstantDefinition: references.add( e )			
			EnumDefinition: references.addAll( e.values )
			default: false			
		}
	}
	
	def getReferenceableElementsBefore( Element e ) {
		var model = e.getContainerOfType(typeof(Model))
		if (model != null) {
			var idx = model.elements.indexOf(e)
			if (idx < 0) {
				IScope::NULLSCOPE
			} else {
				val references = newLinkedList()
				model.elements.subList(0,idx).forEach[ it.addReferenceableElements(references) ]
				Scopes::scopeFor( references )
			}
		} else {
			IScope::NULLSCOPE
		}
	}
	
	def scope_ActionStub_activity( SystemDefinition sys ,EReference r ) {
		var model = sys.getContainerOfType(typeof(Model))
		if (model != null) {
			Scopes::scopeFor( model.activities )
		} else {
			IScope::NULLSCOPE
		}
	}
	
	def getContainerScope( EObject cbi ) {
		var forVariables = newLinkedList()
		var parent = cbi.getContainerOfType(typeof(ComponentBlockForStatement))
		while ( parent != null ) {
			forVariables.add( parent.variable )
			parent = parent.eContainer ?. getContainerOfType(typeof(ComponentBlockForStatement))
		}
		var sys = cbi.getContainerOfType(typeof(SystemDefinition))
		Scopes::scopeFor( forVariables , sys ?. getReferenceableElementScopeForElement ?: IScope::NULLSCOPE )
	}
	
	def scope_Reference_reference( ComponentBlockInstantiation cbi , EReference r ) {
		var parentScope = cbi.containerScope
		var comp = cbi.name
		if (comp != null) {
			Scopes::scopeFor( comp.processes.processes , parentScope )
		} else {
			parentScope
		}
	}
	
	def scope_Reference_reference( ComponentBlockForStatement forBlock , EReference r ) {
		var parentScope = forBlock.containerScope
		Scopes::scopeFor( newLinkedList( forBlock.variable ) , parentScope )
	}
	

}
